<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <div class="buttons">
            <button id="theoryButton">Теория</button>
            <button id="progressButton">Вычисления</button>
            <button id="randomButton">Уравнять</button>
        </div>
    </div>
    
    
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://threejs.org/build/three.module.js",
                "three/addons/": "https://threejs.org/examples/jsm/"
            }
        }
    </script>
    <script type="module">

        import * as THREE from 'three';
        //import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EventControls } from 'https://alexan0308.github.io/threejs/examples/js/controls/EventControls.js';

        var camera, scene, renderer;
        var controls, eventControl;
        var ambientLight, light;
        var box, cylinder, table, helperObject;
        const meh = new THREE.Group();
        const dragObjects = [];
        var array_pos = [];
        var obj = [];
        
        init();
        animate();

        function init() {

            var container = document.createElement( 'div' );
            document.body.appendChild( container );

            // CAMERA
            camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 80000 );
            camera.position.set( 0, 0, 0 );
            camera.lookAt(-1, 0, 0);

            // LIGHTS
            ambientLight = new THREE.AmbientLight( 0x333333, 50 );	// 0.2

            light = new THREE.DirectionalLight( 0xFFFFFF, 1.0 );
            light.position.set( 1, 1, 1 );				
            // direction is set in GUI

            // RENDERER
            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            container.appendChild( renderer.domElement );

            // EVENTS
            window.addEventListener( 'resize', onWindowResize, false );

            // // CONTROLS
            // controls = new OrbitControls( camera, renderer.domElement );
            // controls.addEventListener( 'change', render );
            // //controls.rotateSpeed = 1; 
            // controls.enableZoom = true;  
            // controls.zoomSpeed = 0.5;  

            // controls.minDistance = 500;
            // controls.maxDistance = 2500;
            
            // controls.enableDamping = true;

            // scene itself
            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0xD3D3D3 );

            scene.add( ambientLight );
            scene.add( light );


            var materials = [ ];
            var textureLoader = new THREE.TextureLoader();
            for ( let i = 1; i <= 6; i++ ) {
                var texture = textureLoader.load( 'textures/' + String(i) + '.jpg' );
                var material = new THREE.MeshPhongMaterial( 
                { map: texture, side: THREE.BackSide } );
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                if (i==4 || i==3 ) texture.repeat.set( 3, 3 );
                if (i==3) texture.offset.set(0.05, 0.2);
                materials.push( material );
            }              
              
            var geometry = new THREE.BoxGeometry ( 10000, 4000, 7000 );		
            var Cube = new THREE.Mesh( geometry, materials );
            Cube.position.y = 0;
            scene.add( Cube );

            
            
            
            var texture = new THREE.TextureLoader().load( "textures/wood.jpg" );
            var material = new THREE.MeshBasicMaterial( { map:texture, color: 0x955f20 } );
            var boxGeometry = new THREE.BoxGeometry(1500,1200,30);
            var table1 = new THREE.Mesh(boxGeometry, material);
            table1.position.set(-2500, -1400, 1500);


            var boxGeometry = new THREE.BoxGeometry(1500,1200,30);
            var table2 = new THREE.Mesh(boxGeometry, material);
            table2.position.set(-2500, -1400, -1500);
            

            //столешница
            var boxGeometry = new THREE.BoxGeometry(1500,3200,30);
            var table3 = new THREE.Mesh(boxGeometry, material);
            table3.position.set(-2500, -785, 0);
            table3.rotation.x = Math.PI / 2;
            

            //спереди
            var boxGeometry = new THREE.BoxGeometry(2970,1000,30);
            var table4 = new THREE.Mesh(boxGeometry, material);
            table4.position.set(-2000, -1300, 0);
            table4.rotation.y = Math.PI / 2;
            

            table = new THREE.Group();
            table.add(table1);
            table.add(table2);
            table.add(table3);
            table.add(table4);

            scene.add(table);


            //Опора рычага
            var Geometry = new THREE.CylinderGeometry(15,15,1500, 10);
            var Material = new THREE.MeshPhongMaterial({ color: 0x808080 });
            var leverSupport = new THREE.Mesh(Geometry, Material);
            leverSupport.position.set(-2500, -400, 0);
            scene.add(leverSupport);

            //рычаг
            var lever = new THREE.Group();
            var leverGeometry = new THREE.BoxGeometry(30,80,2000);
            var leverMaterial = new THREE.MeshPhongMaterial({ color: 0x804030 });
            var ruler = new THREE.Mesh(leverGeometry, leverMaterial);
            lever.add(ruler);
            //засечки
            for ( let z = -900; z <= 900; z += 200) {
                var markGeometry = new THREE.BoxGeometry(30, 40, 5); 
                var markMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 }); 
                var mark = new THREE.Mesh(markGeometry, markMaterial);
                mark.position.set(1, -20, z); 
                lever.add(mark);
            }

            //helperObject
            var helperObjectGeometry = new THREE.CylinderGeometry(10,10,32,10);
            var helperObjectMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            helperObject = new THREE.Mesh( helperObjectGeometry, helperObjectMaterial );
            helperObject.position.set(-2500,200,0);
            helperObject.rotation.z = Math.PI / 2;
            scene.add(helperObject);

            
            //грузы
            var createSinker = function(force, x, y, z) {
            var sinkerGroup = new THREE.Group();
            sinkerGroup.force = force;

            var markMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            var markGeometry = new THREE.CylinderGeometry(7, 7, 180, 10);
            var mark = new THREE.Mesh(markGeometry, markMaterial);
            mark.position.set(0, 80, 0);

            var Geometry = new THREE.CylinderGeometry(70, 70, 140, 20);
            var materials = [];
            var textureLoader = new THREE.TextureLoader();
            for (let i = 1; i <= 6; i++) {
                if (i == 1) {
                    var texture = textureLoader.load('textures/' + force + 'H.png');
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(2, 1);
                } else {
                    var texture = textureLoader.load('textures/steel.png');
                }
                var material = new THREE.MeshPhongMaterial({ map: texture });
                materials.push(material);
            }
            var sinker = new THREE.Mesh(Geometry, materials);
            sinkerGroup.add(sinker);
            sinkerGroup.add(mark);
            sinkerGroup.position.set(x, y, z);
            array_pos.push( new THREE.Vector3().copy(sinkerGroup.position));
            scene.add(sinkerGroup);dragObjects.push(sinkerGroup);
            obj.push(sinkerGroup);
            return sinkerGroup;
            };

            var bigSinker = createSinker(1, -2200, -700, 1000);
            var copiedSinker1 = createSinker(1, -2200, -700, 800);
            var copiedSinker2 = createSinker(2, -2200, -700, 600);
            var copiedSinker3 = createSinker(3, -2200, -700, 400);
            var copiedSinker4 = createSinker(4, -2200, -700, 200);
            var copiedSinker5 = createSinker(1, -2200, -700, -200);
            var copiedSinker6 = createSinker(1, -2200, -700, -400);
            var copiedSinker7 = createSinker(2, -2200, -700, -600);
            var copiedSinker8 = createSinker(3, -2200, -700, -800);
            var copiedSinker9 = createSinker(4, -2200, -700, -1000);

              


            //груз
            // var bigSinker = new THREE.Group();
            // bigSinker.force = 1;
            // var markMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            // var markGeometry = new THREE.CylinderGeometry( 7, 7, 180, 10 );
            // var mark = new THREE.Mesh(markGeometry, markMaterial);
            // mark.position.set(0, 80, 0);
            // var Geometry = new THREE.CylinderGeometry( 70, 70, 140, 20 );
            // var materials = [ ];
            // var textureLoader = new THREE.TextureLoader();
            // for ( let i = 1; i <= 6; i++ ) {
            //     if (i == 1) {
            //         var texture = textureLoader.load( 'textures/' + bigSinker.force + 'H.png' );
            //         texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            //         texture.repeat.set( 2, 1 );
            //     } else {
            //         var texture = textureLoader.load( 'textures/steel.png' );
            //     }
            //     var material = new THREE.MeshPhongMaterial( { map: texture } );
            //     materials.push( material );
            // }
            // var sinker = new THREE.Mesh(Geometry, materials);
            // bigSinker.add(sinker);
            // bigSinker.add(mark);
            // bigSinker.position.set(-2200, -700, 1000);
            // array_pos.push( new THREE.Vector3().copy( bigSinker.position ) );
            // scene.add(bigSinker);dragObjects.push( bigSinker );
            // obj.push(bigSinker);
            

            // //копия груза
            // var copiedSinker = bigSinker.clone();
            // copiedSinker.position.set(-2200, -700, 800);
            // copiedSinker.force = 1;
            // var materials = [ ];
            // var textureLoader = new THREE.TextureLoader();
            // for ( let i = 1; i <= 6; i++ ) {
            //     if (i == 1) {
            //         var texture = textureLoader.load( 'textures/' + copiedSinker.force + 'H.png' );
            //         texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            //         texture.repeat.set( 2, 1 );
            //     } else {
            //         var texture = textureLoader.load( 'textures/steel.png' );
            //     }
            //     var material = new THREE.MeshPhongMaterial( { map: texture } );
            //     materials.push( material );
            // }
            // copiedSinker.children[0].material = materials;
            // array_pos.push( new THREE.Vector3().copy( copiedSinker.position ) );
            // scene.add(copiedSinker);dragObjects.push( copiedSinker );
            // obj.push(copiedSinker);

            // var copiedSinker = bigSinker.clone();
            // copiedSinker.position.set(-2200, -700, 600);
            // copiedSinker.force = 2;
            // var materials = [ ];
            // var textureLoader = new THREE.TextureLoader();
            // for ( let i = 1; i <= 6; i++ ) {
            //     if (i == 1) {
            //         var texture = textureLoader.load( 'textures/' + copiedSinker.force + 'H.png' );
            //         texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            //         texture.repeat.set( 2, 1 );
            //     } else {
            //         var texture = textureLoader.load( 'textures/steel.png' );
            //     }
            //     var material = new THREE.MeshPhongMaterial( { map: texture } );
            //     materials.push( material );
            // }
            // copiedSinker.children[0].material = materials;
            // array_pos.push( new THREE.Vector3().copy( copiedSinker.position ) );
            // scene.add(copiedSinker);dragObjects.push( copiedSinker );
            // obj.push(copiedSinker);

            // var copiedSinker = bigSinker.clone();
            // copiedSinker.position.set(-2200, -700, 400);
            // copiedSinker.force = 3;
            // var materials = [ ];
            // var textureLoader = new THREE.TextureLoader();
            // for ( let i = 1; i <= 6; i++ ) {
            //     if (i == 1) {
            //         var texture = textureLoader.load( 'textures/' + copiedSinker.force + 'H.png' );
            //         texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            //         texture.repeat.set( 2, 1 );
            //     } else {
            //         var texture = textureLoader.load( 'textures/steel.png' );
            //     }
            //     var material = new THREE.MeshPhongMaterial( { map: texture } );
            //     materials.push( material );
            // }
            // copiedSinker.children[0].material = materials;
            // array_pos.push( new THREE.Vector3().copy( copiedSinker.position ) );
            // scene.add(copiedSinker);dragObjects.push( copiedSinker );
            // obj.push(copiedSinker);

            // var copiedSinker = bigSinker.clone();
            // copiedSinker.position.set(-2200, -700, 200);
            // copiedSinker.force = 4;
            // var materials = [ ];
            // var textureLoader = new THREE.TextureLoader();
            // for ( let i = 1; i <= 6; i++ ) {
            //     if (i == 1) {
            //         var texture = textureLoader.load( 'textures/' + copiedSinker.force + 'H.png' );
            //         texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            //         texture.repeat.set( 2, 1 );
            //     } else {
            //         var texture = textureLoader.load( 'textures/steel.png' );
            //     }
            //     var material = new THREE.MeshPhongMaterial( { map: texture } );
            //     materials.push( material );
            // }
            // copiedSinker.children[0].material = materials;
            // array_pos.push( new THREE.Vector3().copy( copiedSinker.position ) );
            // scene.add(copiedSinker);dragObjects.push( copiedSinker );
            // obj.push(copiedSinker);

            // var copiedSinker = bigSinker.clone();
            // copiedSinker.position.set(-2200, -700, -200);
            // copiedSinker.force = 1;
            // var materials = [ ];
            // var textureLoader = new THREE.TextureLoader();
            // for ( let i = 1; i <= 6; i++ ) {
            //     if (i == 1) {
            //         var texture = textureLoader.load( 'textures/' + copiedSinker.force + 'H.png' );
            //         texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            //         texture.repeat.set( 2, 1 );
            //     } else {
            //         var texture = textureLoader.load( 'textures/steel.png' );
            //     }
            //     var material = new THREE.MeshPhongMaterial( { map: texture } );
            //     materials.push( material );
            // }
            // copiedSinker.children[0].material = materials;
            // array_pos.push( new THREE.Vector3().copy( copiedSinker.position ) );
            // scene.add(copiedSinker);dragObjects.push( copiedSinker );
            // obj.push(copiedSinker);

            // var copiedSinker = bigSinker.clone();
            // copiedSinker.position.set(-2200, -700, -400);
            // copiedSinker.force = 1;
            // var materials = [ ];
            // var textureLoader = new THREE.TextureLoader();
            // for ( let i = 1; i <= 6; i++ ) {
            //     if (i == 1) {
            //         var texture = textureLoader.load( 'textures/' + copiedSinker.force + 'H.png' );
            //         texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            //         texture.repeat.set( 2, 1 );
            //     } else {
            //         var texture = textureLoader.load( 'textures/steel.png' );
            //     }
            //     var material = new THREE.MeshPhongMaterial( { map: texture } );
            //     materials.push( material );
            // }
            // copiedSinker.children[0].material = materials;
            // array_pos.push( new THREE.Vector3().copy( copiedSinker.position ) );
            // scene.add(copiedSinker);dragObjects.push( copiedSinker );
            // obj.push(copiedSinker);

            // var copiedSinker = bigSinker.clone();
            // copiedSinker.position.set(-2200, -700, -600);
            // copiedSinker.force = 2;
            // var materials = [ ];
            // var textureLoader = new THREE.TextureLoader();
            // for ( let i = 1; i <= 6; i++ ) {
            //     if (i == 1) {
            //         var texture = textureLoader.load( 'textures/' + copiedSinker.force + 'H.png' );
            //         texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            //         texture.repeat.set( 2, 1 );
            //     } else {
            //         var texture = textureLoader.load( 'textures/steel.png' );
            //     }
            //     var material = new THREE.MeshPhongMaterial( { map: texture } );
            //     materials.push( material );
            // }
            // copiedSinker.children[0].material = materials;
            // array_pos.push( new THREE.Vector3().copy( copiedSinker.position ) );
            // scene.add(copiedSinker);dragObjects.push( copiedSinker );
            // obj.push(copiedSinker);

            // var copiedSinker = bigSinker.clone();
            // copiedSinker.position.set(-2200, -700, -800);
            // copiedSinker.force = 3;
            // var materials = [ ];
            // var textureLoader = new THREE.TextureLoader();
            // for ( let i = 1; i <= 6; i++ ) {
            //     if (i == 1) {
            //         var texture = textureLoader.load( 'textures/' + copiedSinker.force + 'H.png' );
            //         texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            //         texture.repeat.set( 2, 1 );
            //     } else {
            //         var texture = textureLoader.load( 'textures/steel.png' );
            //     }
            //     var material = new THREE.MeshPhongMaterial( { map: texture } );
            //     materials.push( material );
            // }
            // copiedSinker.children[0].material = materials;
            // array_pos.push( new THREE.Vector3().copy( copiedSinker.position ) );
            // scene.add(copiedSinker);dragObjects.push( copiedSinker );
            // obj.push(copiedSinker);
            
            // var copiedSinker = bigSinker.clone();
            // copiedSinker.position.set(-2200, -700, -1000);
            // copiedSinker.force = 4;
            // var materials = [ ];
            // var textureLoader = new THREE.TextureLoader();
            // for ( let i = 1; i <= 6; i++ ) {
            //     if (i == 1) {
            //         var texture = textureLoader.load( 'textures/' + copiedSinker.force + 'H.png' );
            //         texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            //         texture.repeat.set( 2, 1 );
            //     } else {
            //         var texture = textureLoader.load( 'textures/steel.png' );
            //     }
            //     var material = new THREE.MeshPhongMaterial( { map: texture } );
            //     materials.push( material );
            // }
            // copiedSinker.children[0].material = materials;
            // array_pos.push( new THREE.Vector3().copy( copiedSinker.position ) );
            // scene.add(copiedSinker);dragObjects.push( copiedSinker );
            // obj.push(copiedSinker);

            


            //движущаяся часть
            meh.position.set(-2500, 200, 0);
            meh.add(lever);
            scene.add(meh);
            for (let i = -900; i <= 900; i += 200) {
                const pos = new THREE.Group();
                pos.name = i;  // Измените имя по своему усмотрению
                pos.position.z = i;  // Rоордината z на основе счетчика цикла
                pos.position.y = -40;
                pos.force = 0;
                meh.add(pos);
            }
            


            //Рабочее поле вертикаольное
            var Material = new THREE.MeshPhongMaterial( { color: 0xD3D3D3, side: THREE.DoubleSide, transparent: true, opacity: 0 } );
            var Geometry = new THREE.PlaneGeometry( 3000, 1500, 1, 1 );
            var Board = new THREE.Group();
            var checkerboard = new THREE.Mesh( Geometry, Material );
            checkerboard.position.x = -2500;
            checkerboard.position.y = -300;
            checkerboard.rotation.y =  Math.PI / 2;
            Board.add( checkerboard );
            //Рабочее поле горизонтальное
            var Material2 = new THREE.MeshPhongMaterial( { color: 0x0F0FF0, side: THREE.DoubleSide, transparent: true, opacity: 0 } );
            var Geometry2 = new THREE.PlaneGeometry( 800, 3000, 1, 1 );
            var checkerboard2 = new THREE.Mesh( Geometry2, Material2 );
            checkerboard2.position.x = -2100;
            checkerboard2.position.y = -769;
            checkerboard2.rotation.x =  Math.PI / 2;
            Board.add( checkerboard2 ); scene.add( Board );

            




            
            //Перемещение объектов
            eventControl = new EventControls( [ ... dragObjects ], camera, renderer.domElement );
            eventControl.setDraggable( render, true );              
            eventControl.setMap ( Board );
            //eventControl.setOrbitControl( controls );          
            eventControl.attachEvent( 'dragAndDrop', function () {
                this.event.object.parent.remove(this.event.object);
                scene.add(this.event.object);
                this.event.object.position.z = Math.max(-999, Math.min(999, this.event.object.position.z));
                this.event.object.position.y = Math.max(-700, Math.min(200, this.event.object.position.y));
            }); 


            // eventControl.attachEvent( 'click', function () {
            //     console.log( "object #" + this.event.item );
            // });
            
            
            eventControl.attachEvent( 'mouseUp', function () {
                this.event.object.parent.remove(this.event.object);
                scene.add(this.event.object);
                this.event.object.position.z = 300 + 200 * Math.round((this.event.object.position.z - 300) / 200);
                let key = false;
                for ( let i = 1; i < meh.children.length; i++ ) {
                    if (meh.children[i].position.z == this.event.object.position.z && meh.children[i].children.length < 4) {
                        key = true;
                    } 
                }
                if ( this.event.object.position.y > -700 && this.event.object.position.x != 0 && key ) { 
                    addObject(this.event.object)
                } else {
                    this.event.object.position.copy( array_pos[ this.event.item ] ); 
                    for (let i = 1; i < meh.children.length; i++) {
                        for (let j = 0; j < meh.children[i].children.length; j++){
                            meh.children[i].children[j].position.y = -120 - 180*j;
                        };
                    }
                }
                if (document.getElementById('progress')) {
                    close();
                    workProgress();
                }
            });
        }

        // EVENT HANDLERS

        


        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        
        function animateLeft() {
            meh.rotation.x -= 0.01;
            for (let i = 1; i < meh.children.length; i++) {
                meh.children[i].rotation.x += 0.01;
            }
        }
        function animateRight() {
            meh.rotation.x += 0.01;
            for (let i = 1; i < meh.children.length; i++) {
                meh.children[i].rotation.x -= 0.01;
            }
        }
        function animate() {
            var momentum = 0;
            for ( let i = 1; i < meh.children.length; i++) {
                var force = 0;
                for ( let j = 0; j < meh.children[i].children.length; j++) {
                    force += meh.children[i].children[j].force
                }
                momentum += meh.children[i].position.z * force;
            }

            if (momentum == 0){
                if (Math.abs(meh.rotation.x) < 0.05) {
                    meh.rotation.x = 0;
                    for (let i = 1; i < meh.children.length; i++) {
                        meh.children[i].rotation.x = 0;
                    }
                } else if (meh.rotation.x < 0) {
                    animateRight();
                } else if (meh.rotation.x > 0) {
                    animateLeft();
                }
            } else if (momentum < 0 && meh.rotation.x > -0.2) {
                animateLeft();
            } else if (momentum > 0 && meh.rotation.x < 0.2) {
                animateRight();
            }
            
            requestAnimationFrame( animate );
            //controls.update(); //
            render();
        }

        function render() {
            renderer.render( scene, camera );
        }			
        
        // Кнопка Вычислеения
        const progressButton = document.getElementById('progressButton');
        progressButton.addEventListener("click", function() {
            if (!document.getElementById('progress')) {
                close();
                workProgress();
            } else {
                close();
            }
        });
        
        // Кнопка Теория
        const theoryButton = document.getElementById("theoryButton");
        theoryButton.addEventListener("click", function() {
            if (!document.getElementById('theory')) {
                close();
                openTheory();
            } else {
                close();
            }
        });

        // Кнопка уравнять
        const randomButton = document.getElementById("randomButton");
        randomButton.addEventListener("click", function() {
            equalize();
        });

        function close() {
            if (document.getElementById('theory')) document.getElementById('theory').remove();
            if (document.getElementById('progress')) document.getElementById('progress').remove();
        }

        function openTheory() {
            // Создаем div-элемент
            var container = document.querySelector('.container');
            var theory = document.createElement('div');
            theory.className = 'theory';
            theory.id = 'theory';
            theory.innerHTML = `
                <div class="content">
                    <section class="definition">
                        <h2>Плечо силы</h2>
                        <p>Плечом силы называется расстояние от точки опоры до линии действия силы.</p>
                        <p class="designation">Обозначение: <span class="formula">l</span></p> 
                        <p class="designation">Единица измерения в СИ: <span class="formula">м</span></p> 
                    </section>
                    <section class="definition">
                        <h2>Момент силы</h2>
                        <p>Моментом силы называется произведение величины этой силы на ее плечо.</p>
                        <p class="designation">Обозначение: <span class="formula">M</span></p> 
                        <p class="designation">Единица измерения в СИ: <span class="formula">Н·м</span></p> 
                    </section>
                </div>
                <section class="rule">
                    <h2>Правило моментов</h2>
                    <p>Рычаг находится в положении равновесия, если момент силы, вращающей его по часовой стрелке, равен моменту силы, вращающей его против часовой стрелки.</p>
                    <p><span class="formula">M₁ = M₂</span></p>
                    <p><span class="formula">F₁l₁ = F₂l₂</span></p>
                </section>
            `;
            container.appendChild(theory);
        }

        function workProgress() {
            var container = document.querySelector('.container');
            var progress = document.createElement('div');
            progress.id = 'progress';

            // Создаем таблицу
            var table = document.createElement('table');
            table.setAttribute('cellspacing', '0');
            table.setAttribute('cellpadding', '5');

            // Создаем заголовок таблицы
            var thead = document.createElement('thead');
            var headerRow = document.createElement('tr');
            headerRow.style.backgroundColor = 'lightgray';
            var headers = ['№ позиции', 'F, Н', 'l, м', 'M, Н·м'];
            headers.forEach(function(headerText) {
                var th = document.createElement('th');
                th.style.border = '1px solid black';
                th.style.width = '80px';
                th.style.height = '30px';
                th.textContent = headerText;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Создаем тело таблицы
            var tbody = document.createElement('tbody');
            var m = moment().reverse();
            var f = forces().reverse();
            var l = lengths().reverse();
            var results = [];
            for (let i = 0; i < m.length; i++) {
                results.push(i+1, m[i], f[i], l[i]);
            }
            for (let i = 0; i < m.length; i++) {
                if (m[i]!=0) {
                    var bodyRow = document.createElement('tr');
                    bodyRow.style.backgroundColor = 'white';
                    var ids = ['num','F', 'l', 'm'];
                    for (let j = 0; j < ids.length; j++) {
                        var td = document.createElement('td');
                        td.setAttribute('id', ids[j] + i);
                        td.style.border = '1px solid black';
                        td.style.width = '80px';
                        td.style.height = '30px';
                        if (j == 0) {
                            td.innerHTML = i+1;
                        } if (j == 1) {
                            td.innerHTML = f[i];
                        } if (j == 2) {
                            if (l[i] < 0) {
                                td.innerHTML = (-1) * l[i];
                            } else {
                                td.innerHTML = l[i];
                            }
                        } if (j == 3) {
                            if (m[i] < 0) {
                                td.innerHTML = (-1) * m[i];
                            } else {
                                td.innerHTML = m[i];
                            }
                        }
                        bodyRow.appendChild(td);
                    }
                    if (i < 5 && !leftM) {
                        var td = document.createElement('td');
                        td.setAttribute('id', 'leftM');
                        td.style.border = '1px solid black';
                        td.style.width = '80px';
                        td.style.height = '30px';
                        var leftM = m.slice(0,5);
                        var sum = 0;
                        for (let j = 0; j < leftM.length; j++) {
                            sum += Number(leftM[j]);
                        }
                        td.innerHTML = 'Момент силы слева\n' + sum.toFixed(2);
                        bodyRow.appendChild(td);
                    }
                    if (i >= 5 && !rightM) {
                        var td = document.createElement('td');
                        td.setAttribute('id', 'rightM');
                        td.style.border = '1px solid black';
                        td.style.width = '80px';
                        td.style.height = '30px';
                        var rightM = m.slice(5,10);
                        var sum = 0;
                        for (let j = 0; j < rightM.length; j++) {
                            sum += (-1) * Number(rightM[j]);
                        }
                        td.innerHTML = 'Момент силы справа\n' + sum.toFixed(2);
                        bodyRow.appendChild(td);
                    }
                    tbody.appendChild(bodyRow);
                }
                
                
            }
            table.appendChild(tbody);
            progress.appendChild(table);
            container.appendChild(progress);
        }

        function moment() {
            var m = [];
            for (let i = 1; i < meh.children.length; i++) {
                var force = 0;
                for ( let j = 0; j < meh.children[i].children.length; j++) {
                    force += meh.children[i].children[j].force;
                }
                m.push(((meh.children[i].position.z / 2000) * force).toFixed(2));
            }
            return(m);
        }
        function forces() {
            var f = [];
            for (let i = 1; i < meh.children.length; i++) {
                var force = 0;
                for ( let j = 0; j < meh.children[i].children.length; j++) {
                    force += meh.children[i].children[j].force;
                }
                f.push(force.toFixed(2));
            }
            return(f);
        }
        function lengths() {
            var l = [];
            for (let i = 1; i < meh.children.length; i++) {
                l.push((meh.children[i].position.z / 2000).toFixed(2));
            }
            return(l);
        }


        function equalize() {
            var m = moment();
            var sum = 0;
            for (let i = 0; i < m.length; i++){
                sum += Number(m[i])
            }
            sum = Number(sum.toFixed(2));
            if (sum != 0) {
                var key = true;
                for ( let i = 0; i < obj.length; i++ ) {
                    if (obj[i].position.x != 0 && key) {
                        for (let j = 1; j < meh.children.length; j++){
                            var elem = Number((obj[i].force * (meh.children[j].position.z / 2000 )).toFixed(2))
                            if (sum + elem == 0 && meh.children[j].children.length < 4) {
                                obj[i].position.z = meh.children[j].position.z;
                                addObject(obj[i]);
                                key = false;
                                break;
                            }
                        }
                    } 
                    if (!key) {
                        break
                    }
                }
                if (key) {
                    notification('Нельзя уравнять путем добавления одного груза')
                }
            }
            if (document.getElementById('progress')) {
                close();
                workProgress();
            }
        }

        function addObject(object) {
            object.position.x = 0;
            object.position.z = 300 + 200 * Math.round((object.position.z - 300) / 200);
            for (let i = 1; i < meh.children.length; i++) {
                if (object.position.z == meh.children[i].position.z) {
                    object.position.z = 0;
                    meh.children[i].add(object)
                }
                for (let j = 0; j < meh.children[i].children.length; j++){
                    meh.children[i].children[j].position.y = -120 - 180*j;
                }
            }
            
        }

        function notification(message) {
            if (!document.getElementById('notification')) {
                var notification = document.createElement('div');
                notification.id = 'notification';
                notification.textContent = message;
                notification.style.position = 'fixed';
                notification.style.top = '15%'; // Расположение сверху экрана
                notification.style.left = '50%';
                notification.style.transform = 'translateX(-50%)'; // Центрирование по горизонтали
                notification.style.color = 'red'; // Красный цвет текста
                notification.style.zIndex = '9999';
                notification.style.transition = 'opacity 1.5s ease-out'; // Плавное исчезновение
                notification.style.userSelect = 'none';
                notification.style.fontSize = '20px';
                // Добавляем уведомление на страницу
                document.body.appendChild(notification);
                // Устанавливаем таймер для удаления уведомления через некоторое время
                setTimeout(function() {
                    notification.style.opacity = '0'; // Устанавливаем прозрачность на 0 для плавного исчезновения
                    setTimeout(function() {
                        document.getElementById('notification').remove(); // Удаляем уведомление после завершения анимации
                    }, 1500); // Ждем 1.5 секунды (время анимации)
                }, 1000);
            }
        }

    </script>
</body>
</html>