<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link type="text/css" rel="stylesheet" href="https://threejs.org/examples/main.css">
</head>
<body>
    
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://threejs.org/build/three.module.js",
                "three/addons/": "https://threejs.org/examples/jsm/"
            }
        }
    </script>
    <script type="module">

        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EventControls } from 'https://alexan0308.github.io/threejs/examples/js/controls/EventControls.js';

        var camera, scene, renderer;
        var controls, eventControl;
        var ambientLight, light;
        var lever, box, cylinder, table, helperObject;
        const meh = new THREE.Group();
        const dragObjects = [];
        var array_pos = [];
        var isAnimating = false;
        
        init();
        animate();

        function init() {

            var container = document.createElement( 'div' );
            document.body.appendChild( container );

            // CAMERA
            camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 80000 );
            camera.position.set( 10, 0, 0 );

            // LIGHTS
            ambientLight = new THREE.AmbientLight( 0x333333, 50 );	// 0.2

            light = new THREE.DirectionalLight( 0xFFFFFF, 1.0 );
            light.position.set( 1, 1, 1 );				
            // direction is set in GUI

            // RENDERER
            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            container.appendChild( renderer.domElement );

            // EVENTS
            window.addEventListener( 'resize', onWindowResize, false );

            // CONTROLS
            controls = new OrbitControls( camera, renderer.domElement );
            controls.addEventListener( 'change', render );
            //controls.rotateSpeed = 1; 
            controls.enableZoom = true;  
            controls.zoomSpeed = 0.5;  

            controls.minDistance = 500;
            controls.maxDistance = 2500;
            
            controls.enableDamping = true;

            // scene itself
            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0xD3D3D3 );

            scene.add( ambientLight );
            scene.add( light );


            var materials = [ ];
            var textureLoader = new THREE.TextureLoader();
            for ( let i = 1; i <= 6; i++ ) {
                var texture = textureLoader.load( 'textures/' + String(i) + '.jpg' );
                var material = new THREE.MeshPhongMaterial( 
                { map: texture, side: THREE.BackSide } );
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                if (i==4 || i==3 ) texture.repeat.set( 3, 3 );
                if (i==3) texture.offset.set(0.05, 0.2);
                materials.push( material );
            }              
              
            var geometry = new THREE.BoxGeometry ( 10000, 4000, 7000 );		
            var Cube = new THREE.Mesh( geometry, materials );
            Cube.position.y = 0;
            scene.add( Cube );

            
            
            
            var texture = new THREE.TextureLoader().load( "textures/wood.jpg" );
            var material = new THREE.MeshBasicMaterial( { map:texture, color: 0x955f20 } );
            var boxGeometry = new THREE.BoxGeometry(1500,1200,30);
            var table1 = new THREE.Mesh(boxGeometry, material);
            table1.position.set(-2500, -1400, 1500);


            var boxGeometry = new THREE.BoxGeometry(1500,1200,30);
            var table2 = new THREE.Mesh(boxGeometry, material);
            table2.position.set(-2500, -1400, -1500);
            

            //столешница
            var boxGeometry = new THREE.BoxGeometry(1500,3200,30);
            var table3 = new THREE.Mesh(boxGeometry, material);
            table3.position.set(-2500, -785, 0);
            table3.rotation.x = Math.PI / 2;
            

            //спереди
            var boxGeometry = new THREE.BoxGeometry(2970,1000,30);
            var table4 = new THREE.Mesh(boxGeometry, material);
            table4.position.set(-2000, -1300, 0);
            table4.rotation.y = Math.PI / 2;
            

            table = new THREE.Group();
            table.add(table1);
            table.add(table2);
            table.add(table3);
            table.add(table4);

            scene.add(table);


            //Опора рычага
            var Geometry = new THREE.CylinderGeometry(15,15,1500, 10);
            var Material = new THREE.MeshPhongMaterial({ color: 0x808080 });
            var leverSupport = new THREE.Mesh(Geometry, Material);
            leverSupport.position.set(-2500, -400, 0);
            scene.add(leverSupport);

            //рычаг
            var leverGeometry = new THREE.BoxGeometry(30,80,2000);
            var leverMaterial = new THREE.MeshPhongMaterial({ color: 0x804030 });
            var lever = new THREE.Mesh(leverGeometry, leverMaterial);
            //lever.position.set(-2500, 200, 0);
            
            scene.add(lever);

            //helperObject
            var helperObjectGeometry = new THREE.CylinderGeometry(10,10,32,10);
            var helperObjectMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            helperObject = new THREE.Mesh( helperObjectGeometry, helperObjectMaterial );
            helperObject.position.set(-2500,200,0);
            helperObject.rotation.z = Math.PI / 2;
            scene.add(helperObject);


            


            //груз1
            var sinker = new THREE.Group();
            var markMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            var markGeometry = new THREE.BoxGeometry(10,80,10);
            var mark = new THREE.Mesh(markGeometry, markMaterial);
            mark.position.set(0, 110, 0)
            sinker.add(mark);
            var Geometry = new THREE.BoxGeometry(140,140,140);
            var Material = new THREE.MeshPhongMaterial({ color: 0xC0C0C0 });
            var obj = new THREE.Mesh(Geometry, Material);
            sinker.add(obj);
            sinker.position.set(-2000, -700, -500);
            sinker.force = 10;
            array_pos.push( new THREE.Vector3().copy( sinker.position ) );
            scene.add(sinker);dragObjects.push( sinker );
            

            
            //груз2
            var sinker2 = sinker.clone();
            sinker2.position.set(-2000, -700, 500);
            sinker2.force = 10;
            array_pos.push( new THREE.Vector3().copy( sinker2.position ) );
            scene.add(sinker2);dragObjects.push( sinker2 );


            //груз3
            var sinker3 = new THREE.Group();
            var markMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            var markGeometry = new THREE.BoxGeometry(10,80,10);
            var mark = new THREE.Mesh(markGeometry, markMaterial);
            mark.position.set(0, 110, 0)
            sinker3.add(mark);
            var Geometry = new THREE.BoxGeometry(70,70,70);
            var Material = new THREE.MeshPhongMaterial({ color: 0xC0C0C0 });
            var obj = new THREE.Mesh(Geometry, Material);
            obj.position.set(0, 40, 0)
            sinker3.add(obj);
            sinker3.position.set(-2000, -770, 200);
            sinker3.force = 5;
            array_pos.push( new THREE.Vector3().copy( sinker3.position ) );
            scene.add(sinker3);dragObjects.push( sinker3 );

            //груз4
            var sinker4 = sinker3.clone();
            sinker4.position.set(-2000, -770, -200);
            sinker4.force = 5;
            array_pos.push( new THREE.Vector3().copy( sinker4.position ) );
            scene.add(sinker4);dragObjects.push( sinker4 );

            
            //движущаяся часть
            meh.position.set(-2500, 200, 0);
            meh.add(lever);
            scene.add(meh);
            


            //Рабочее поле вертикаольное
            var Material = new THREE.MeshPhongMaterial( { color: 0xD3D3D3, side: THREE.DoubleSide, transparent: true, opacity: 0 } );
            var Geometry = new THREE.PlaneGeometry( 2000, 1000, 1, 1111 );
            var Board = new THREE.Group();
            var checkerboard = new THREE.Mesh( Geometry, Material );
            checkerboard.position.x = -2500;
            checkerboard.position.y = -300;
            checkerboard.rotation.y =  Math.PI / 2;
            Board.add( checkerboard );
            //Рабочее поле горизонтальное
            var Material2 = new THREE.MeshPhongMaterial( { color: 0x0F0FF0, side: THREE.DoubleSide, transparent: true, opacity: 0  } );
            var Geometry2 = new THREE.PlaneGeometry( 800, 2000, 1, 1 );
            var checkerboard2 = new THREE.Mesh( Geometry2, Material2 );
            checkerboard2.position.x = -2100;
            checkerboard2.position.y = -769;
            checkerboard2.rotation.x =  Math.PI / 2;
            Board.add( checkerboard2 ); scene.add( Board );



            var array_newpos = [];
            //Перемещение объектов
            eventControl = new EventControls( [ ... dragObjects ], camera, renderer.domElement );
            eventControl.setDraggable( render, true );              
            eventControl.setMap ( Board );
            eventControl.setOrbitControl( controls );          
            
            eventControl.attachEvent( 'dragAndDrop', function () {
                const MIN_Z = -900;
                const MAX_Z = 900;
                if (this.event.object.position.y > -20 ) {
                    meh.remove(this.event.object);
                    this.event.object.rotation.x = 0;
                    scene.add(this.event.object);
                    this.event.object.position.z = Math.max(MIN_Z, Math.min(MAX_Z, 300 + 200 * Math.round((this.event.object.position.z - 300) / 200)));
                    this.event.object.position.y = 45;
                    this.event.object.position.x = -2500;
                    
                } 
                // else {
                //     this.event.object.position.z = Math.max(MIN_Z, Math.min(MAX_Z, this.event.object.position.z));
                // }
                
            }); 
            eventControl.attachEvent( 'click', function () {
                if (this.event.object.position.x == 0) {
                    meh.remove(this.event.object);
                    this.event.object.rotation.x = 0;
                    scene.add(this.event.object);
                    this.event.object.position.x = -2500;
                }
                console.log( "object #" + this.event.item );

            });
            
            
            eventControl.attachEvent( 'mouseUp', function () {

            if ( this.event.object.position.y > -20 && this.event.object.position.y < 90 && !array_newpos.includes(this.event.object.position.z)  ) { 
                array_newpos[this.event.item] = this.event.object.position.z;
                this.event.object.position.set(0, -155, array_newpos[this.event.item]);
                this.event.object.rotation.x = (-1) * meh.rotation.x;
                meh.add(this.event.object);
                //momentum += this.event.object.position.z * this.event.object.force;
                dvizh();
            } else {
                meh.remove(this.event.object);
                this.event.object.rotation.x = 0;
                scene.add(this.event.object);
                this.event.object.position.copy( array_pos[ this.event.item ] ); 
                render();
                array_newpos[this.event.item] = NaN;
            }
            
            if (this.event.object.position.z == -100 && this.event.object.position.y == 45){
                animateRight();
            } else {
                animateLeft();
                
            }
            
            console.log('Координаты в массиве array_newpos=', array_newpos);
            console.log('Позиция по z координате', this.event.object.position.z);

            });
            
            
            function dvizh() {

                if (isAnimating){
                    return;
                } else {
                    animaka();
                }
            }
            function animaka() {
                var momentum = 0;
                for ( let i = 1; i < meh.children.length; i++) {
                    momentum += meh.children[i].position.z * meh.children[i].force;
                }
            
                if (momentum == 0){
                    
                    if (meh.rotation.x < 0) {
                        animateRight();
                        isAnimating = true;
                    } else if (meh.rotation.x > 0) {
                        animateLeft();
                        isAnimating = true;
                    }
                    
                } else if (momentum < 0 ) {
                    animateLeft()
                    isAnimating = true;
                } else if (momentum > 0 ) {
                    animateRight()
                    isAnimating = true;
                }
            
                // ограничить вращение
                if (meh.rotation.x > 0.2) {
                    isAnimating = false;
                    meh.rotation.x = 0.2;
                    for (let i = 1; i < meh.children.length; i++) {
                        meh.children[i].rotation.x = -0.2;
                    }
                    isAnimating = false;
                } else if (meh.rotation.x < -0.2) {
                    isAnimating = false;
                    meh.rotation.x = -0.2;
                    for (let i = 1; i < meh.children.length; i++) {
                        meh.children[i].rotation.x = 0.2;
                    }
                    isAnimating = false;
                } else if (Math.abs(meh.rotation.x) < 0.05 && momentum == 0) {
                    isAnimating = false;
                    meh.rotation.x = 0;
                    for (let i = 1; i < meh.children.length; i++) {
                        meh.children[i].rotation.x = 0;
                    }
                }
                requestAnimationFrame(animaka);
                console.log('Моментум = ', momentum);
                console.log('При анимации meh.rotation.x = ', meh.rotation.x)
                }
            

            function animateLeft() {
                meh.rotation.x -= 0.01;
                for (let i = 1; i < meh.children.length; i++) {
                    meh.children[i].rotation.x += 0.01;
                }
            }
            function animateRight() {
                meh.rotation.x += 0.01;
                for (let i = 1; i < meh.children.length; i++) {
                    meh.children[i].rotation.x -= 0.01;
                }
            }

            



        }

        // EVENT HANDLERS

        


        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        //

        function animate() {
            

            
            requestAnimationFrame( animate );
            controls.update(); //
            render();

        }

        function render() {
            
            
            // group.rotation.z += 0.01;
            // if (group.rotation.z > 0.3) {
            //     group.rotation.z = 0.3;
            // }
            renderer.render( scene, camera );

        }			


    </script>
</body>
</html>